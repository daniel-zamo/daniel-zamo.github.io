---
title: IPv4 Subnetting Validation Tools
description: Commands, scripts and tools to verify subnetting calculations, troubleshooting and validation automation.
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 4
sidebar:
  order: 4
  badge:
    text: Tools
    variant: success
---

import { Aside } from '@astrojs/starlight/components';
import { Code } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Card, CardGrid } from '@astrojs/starlight/components';

# IPv4 Subnetting Validation Tools

<Aside type="tip" title="Practical Complement">
This guide complements the fundamental concepts with practical tools to verify and automate subnetting calculations.
</Aside>

Set of commands, scripts and methodologies to validate IPv4 subnetting calculations and perform efficient troubleshooting.

## 1. Validation Commands by System

<Badge text="Multi-Platform" variant="tip" size="small" />

### Linux

<Tabs>
  <TabItem label="ipcalc">
    ```bash title="Standard calculation tool"
    # Basic subnet information
    ipcalc 192.168.1.0/26
    
    # Divide into specific subnets
    ipcalc 192.168.1.0/24 --split 4
    
    # Verify if IP belongs to subnet
    ipcalc 192.168.1.50 192.168.1.0/26
    ```
  </TabItem>
  
  <TabItem label="sipcalc">
    ```bash title="Advanced calculator"
    # Detailed analysis
    sipcalc 192.168.1.0/26
    
    # Multiple subnets
    sipcalc 192.168.1.0/24 -s 26
    
    # Information in different formats
    sipcalc -a 192.168.1.0/26
    ```
  </TabItem>
  
  <TabItem label="subnetcalc">
    ```bash title="Comprehensive information"
    # Complete subnet details
    subnetcalc 192.168.1.0/26
    
    # Specific format
    subnetcalc 192.168.1.0/26 -n
    
    # Address range
    subnetcalc 192.168.1.0/26 -r
    ```
  </TabItem>
</Tabs>

### Windows

<Tabs>
  <TabItem label="Native PowerShell">
    ```powershell title="Network cmdlets"
    # Adapter information
    Get-NetIPConfiguration
    
    # IP details
    Get-NetIPAddress | Where-Object AddressFamily -eq IPv4
    
    # Routing table
    Get-NetRoute -AddressFamily IPv4
    ```
  </TabItem>
  
  <TabItem label="Custom Calculations">
    ```powershell title="Calculation script"
    # Function to calculate subnet
    function Get-SubnetInfo {
        param($NetworkAddress, $PrefixLength)
        # Calculation logic here
    }
    ```
  </TabItem>
</Tabs>

### Python (Multiplatform)

<Tabs>
  <TabItem label="ipaddress Module">
    ```python title="Standard library"
    import ipaddress
    
    # Create network object
    subnet = ipaddress.IPv4Network('192.168.1.0/26')
    
    # Basic information
    print("Network:", subnet.network_address)
    print("Broadcast:", subnet.broadcast_address)
    print("Hosts:", subnet.num_addresses - 2)
    print("Mask:", subnet.netmask)
    
    # Verify if IP is in network
    ip = ipaddress.IPv4Address('192.168.1.50')
    print("IP in network:", ip in subnet)
    ```
  </TabItem>
  
  <TabItem label="Divide Subnets">
    ```python title="Automatic subnetting"
    import ipaddress
    
    # Original network
    original = ipaddress.IPv4Network('192.168.1.0/24')
    
    # Divide into 4 subnets
    subnets = list(original.subnets(new_prefix=26))
    
    for i, subnet in enumerate(subnets, 1):
        print("Subnet", i, ":", subnet)
        first = subnet.network_address + 1
        last = subnet.broadcast_address - 1
        print("  Range:", first, "-", last)
        print("  Hosts:", subnet.num_addresses - 2)
    ```
  </TabItem>
  
  <TabItem label="VLSM Validation">
    ```python title="VLSM verifier"
    def validate_vlsm(subnets_info):
        """Validates VLSM design"""
        subnets = []
        for info in subnets_info:
            subnet = ipaddress.IPv4Network(info['network'])
            start = subnet.network_address
            end = subnet.broadcast_address
            name = info['name']
            subnets.append((start, end, name))
        
        # Sort by start address
        subnets.sort(key=lambda x: x[0])
        
        # Verify overlap
        for i in range(len(subnets) - 1):
            if subnets[i][1] >= subnets[i+1][0]:
                error_msg = "Overlap between " + subnets[i][2] + " and " + subnets[i+1][2]
                return False, error_msg
        
        return True, "Valid VLSM design"
    ```
  </TabItem>
</Tabs>

## 2. Automation Scripts

<Badge text="Automation" variant="caution" size="small" />

### Complete Bash Script

```bash title="subnet_calculator.sh"
#!/bin/bash

# Complete subnetting calculator
subnet_calculator() {
    local ADDRESS=$1
    local CIDR=$2
    
    echo "=== Network Analysis $ADDRESS/$CIDR ==="
    
    # Convert CIDR to decimal mask
    MASK_BITS=$((32 - CIDR))
    HOSTS=$((2**MASK_BITS - 2))
    
    # Calculate mask in decimal
    MASK_VALUE=$((0xFFFFFFFF << MASK_BITS & 0xFFFFFFFF))
    MASK_DEC=$(printf "%d.%d.%d.%d" \
        $((MASK_VALUE >> 24 & 255)) \
        $((MASK_VALUE >> 16 & 255)) \
        $((MASK_VALUE >> 8 & 255)) \
        $((MASK_VALUE & 255)))
    
    echo "Decimal mask: $MASK_DEC"
    echo "Hosts per subnet: $HOSTS"
    echo "Host bits: $MASK_BITS"
    
    # Calculate first and last IP
    IFS='.' read -r a b c d <<< "$ADDRESS"
    NET_INT=$((a * 256**3 + b * 256**2 + c * 256 + d))
    
    FIRST_HOST=$((NET_INT + 1))
    BROADCAST=$((NET_INT + 2**MASK_BITS - 1))
    LAST_HOST=$((BROADCAST - 1))
    
    printf "First IP: %d.%d.%d.%d\n" \
        $((FIRST_HOST >> 24 & 255)) \
        $((FIRST_HOST >> 16 & 255)) \
        $((FIRST_HOST >> 8 & 255)) \
        $((FIRST_HOST & 255))
    
    printf "Last IP: %d.%d.%d.%d\n" \
        $((LAST_HOST >> 24 & 255)) \
        $((LAST_HOST >> 16 & 255)) \
        $((LAST_HOST >> 8 & 255)) \
        $((LAST_HOST & 255))
    
    printf "Broadcast: %d.%d.%d.%d\n" \
        $((BROADCAST >> 24 & 255)) \
        $((BROADCAST >> 16 & 255)) \
        $((BROADCAST >> 8 & 255)) \
        $((BROADCAST & 255))
}

# Usage: subnet_calculator 192.168.1.0 26
```

### Advanced Python Script

```python title="subnet_validator.py"
#!/usr/bin/env python3
import ipaddress
import sys
from typing import List, Tuple, Dict

class SubnetValidator:
    def __init__(self):
        self.errors = []
        self.warnings = []
    
    def validate_basic_subnet(self, subnet_str: str) -> Dict:
        """Basic subnet validation"""
        try:
            subnet = ipaddress.IPv4Network(subnet_str, strict=False)
            return {
                'valid': True,
                'network': str(subnet.network_address),
                'broadcast': str(subnet.broadcast_address),
                'netmask': str(subnet.netmask),
                'prefix_length': subnet.prefixlen,
                'num_hosts': subnet.num_addresses - 2,
                'first_host': str(subnet.network_address + 1),
                'last_host': str(subnet.broadcast_address - 1)
            }
        except ValueError as e:
            return {'valid': False, 'error': str(e)}
    
    def calculate_subnets(self, base_str: str, num_subnets: int) -> List[Dict]:
        """Calculate subnet division"""
        base = ipaddress.IPv4Network(base_str)
        
        # Calculate needed bits
        import math
        bits_needed = math.ceil(math.log2(num_subnets))
        new_prefix = base.prefixlen + bits_needed
        
        if new_prefix > 30:
            error_msg = "New mask /" + str(new_prefix) + " exceeds practical limit /30"
            raise ValueError(error_msg)
        
        subnets = list(base.subnets(new_prefix=new_prefix))
        
        result = []
        for i, subnet in enumerate(subnets[:num_subnets]):
            first = subnet.network_address + 1
            last = subnet.broadcast_address - 1
            range_str = str(first) + " - " + str(last)
            result.append({
                'index': i + 1,
                'network': str(subnet),
                'range': range_str,
                'hosts': subnet.num_addresses - 2
            })
        
        return result

def main():
    validator = SubnetValidator()
    
    if len(sys.argv) < 2:
        print("Usage: python subnet_validator.py <network/cidr>")
        print("Example: python subnet_validator.py 192.168.1.0/24")
        sys.exit(1)
    
    subnet_input = sys.argv[1]
    result = validator.validate_basic_subnet(subnet_input)
    
    if result['valid']:
        print("Network:", result['network'])
        print("Mask:", result['netmask'], "(" + "/" + str(result['prefix_length']) + ")")
        print("Broadcast:", result['broadcast'])
        print("Host range:", result['first_host'], "-", result['last_host'])
        print("Total hosts:", result['num_hosts'])
    else:
        print("Error:", result['error'])

if __name__ == "__main__":
    main()
```

## 3. Troubleshooting Tools

<Badge text="Diagnosis" variant="danger" size="small" />

### Connectivity Verification

<Tabs>
  <TabItem label="Mass Ping">
    ```bash title="Verify IP range"
    #!/bin/bash
    # ping_subnet.sh - Verify active hosts in subnet
    
    subnet_ping() {
        local ADDRESS=$1
        local CIDR=$2
        
        # Convert to IP range
        # Simplified for /24
        BASE="${ADDRESS%.*}"
        
        echo "Scanning $ADDRESS/$CIDR..."
        
        for i in {1..254}; do
            IP="$BASE.$i"
            if ping -c 1 -W 1 "$IP" >/dev/null 2>&1; then
                echo "✓ $IP responds"
            fi
        done
    }
    ```
  </TabItem>
  
  <TabItem label="Nmap">
    ```bash title="Professional network scanning"
    # Host discovery
    nmap -sn 192.168.1.0/24
    
    # Quick port scan
    nmap -F 192.168.1.0/24
    
    # Detect active hosts in multiple subnets
    nmap -sn 192.168.1.0/26 192.168.1.64/26
    ```
  </TabItem>
  
  <TabItem label="PowerShell">
    ```powershell title="Mass testing with PowerShell"
    # Verify connectivity in range
    1..254 | ForEach-Object {
        $IP = "192.168.1.$_"
        if (Test-Connection -ComputerName $IP -Count 1 -Quiet) {
            Write-Host "✓ $IP responds" -ForegroundColor Green
        }
    }
    ```
  </TabItem>
</Tabs>

### Routing Table Analysis

<Tabs>
  <TabItem label="Linux">
    ```bash title="Routing commands"
    # Routing table
    ip route show
    
    # Specific route
    ip route get 192.168.1.50
    
    # Interfaces and addresses
    ip addr show
    
    # ARP information
    ip neigh show
    ```
  </TabItem>
  
  <TabItem label="Windows">
    ```cmd title="Windows commands"
    REM Routing table
    route print
    
    REM Specific route  
    route print 192.168.1.0
    
    REM IP configuration
    ipconfig /all
    
    REM ARP table
    arp -a
    ```
  </TabItem>
</Tabs>

## 4. Mathematical Validation Tests

<Badge text="Verification" variant="tip" size="small" />

### Automated Tests

```python title="test_subnet_math.py"
import unittest
import ipaddress

class TestSubnetMath(unittest.TestCase):
    
    def test_conservation_principle(self):
        """Test: Subnets × Addresses = Original Total"""
        subnet = ipaddress.IPv4Network('192.168.1.0/24')
        subnets = list(subnet.subnets(new_prefix=26))
        
        total_from_subnets = sum(s.num_addresses for s in subnets)
        self.assertEqual(total_from_subnets, subnet.num_addresses)
    
    def test_no_overlap_in_vlsm(self):
        """Test: No overlap in VLSM"""
        subnet_strings = [
            '192.168.1.0/25',   # 0-127
            '192.168.1.128/26', # 128-191  
            '192.168.1.192/27', # 192-223
            '192.168.1.224/28'  # 224-239
        ]
        
        subnets = [ipaddress.IPv4Network(s) for s in subnet_strings]
        
        for i in range(len(subnets) - 1):
            current_end = subnets[i].broadcast_address
            next_start = subnets[i+1].network_address
            error_msg = "Overlap between " + str(subnets[i]) + " and " + str(subnets[i+1])
            self.assertLess(current_end, next_start, error_msg)
    
    def test_host_count_calculation(self):
        """Test: Correct host calculation"""
        test_cases = [
            ('/24', 254),
            ('/25', 126), 
            ('/26', 62),
            ('/27', 30),
            ('/28', 14),
            ('/29', 6),
            ('/30', 2)
        ]
        
        for cidr, expected_hosts in test_cases:
            subnet = ipaddress.IPv4Network('192.168.1.0' + cidr)
            actual_hosts = subnet.num_addresses - 2
            error_msg = "Error in host calculation for " + cidr
            self.assertEqual(actual_hosts, expected_hosts, error_msg)

if __name__ == '__main__':
    unittest.main()
```

## 5. Documentation Tools

### Documentation Generator

```python title="subnet_documentation.py"
import ipaddress
from datetime import datetime

class SubnetDocumentationGenerator:
    def __init__(self):
        self.template = """
# Network Documentation - {subnet_addr}
Generated: {timestamp}

## General Information
- **Base network:** {subnet_addr}
- **Mask:** {netmask} (/{prefix})
- **Total range:** {first_ip} - {last_ip}
- **Total addresses:** {total_addresses}
- **Usable hosts:** {usable_hosts}

## Subnet Division
{subnets_table}

## Recommended Configuration
{config_section}
"""
    
    def generate_subnet_doc(self, subnet_str: str, num_subnets: int = None):
        subnet = ipaddress.IPv4Network(subnet_str)
        
        # Basic information
        doc_data = {
            'subnet_addr': str(subnet),
            'timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'netmask': str(subnet.netmask),
            'prefix': subnet.prefixlen,
            'first_ip': str(subnet.network_address + 1),
            'last_ip': str(subnet.broadcast_address - 1),
            'total_addresses': subnet.num_addresses,
            'usable_hosts': subnet.num_addresses - 2
        }
        
        # Generate subnet table if requested
        if num_subnets:
            import math
            bits_needed = math.ceil(math.log2(num_subnets))
            new_prefix = subnet.prefixlen + bits_needed
            subnets = list(subnet.subnets(new_prefix=new_prefix))
            
            table_rows = []
            for i, sub in enumerate(subnets[:num_subnets], 1):
                first = sub.network_address + 1
                last = sub.broadcast_address - 1
                hosts = sub.num_addresses - 2
                row = "| Subnet " + str(i).rjust(2) + " | " + str(sub) + " | " + str(first) + " - " + str(last) + " | " + str(hosts).rjust(3) + " |"
                table_rows.append(row)
            
            subnets_table = """
| Subnet | CIDR | Host Range | Hosts |
|--------|------|------------|-------|
""" + "\n".join(table_rows)
        else:
            subnets_table = "No subnet division requested."
        
        doc_data['subnets_table'] = subnets_table
        doc_data['config_section'] = self._generate_config_examples(subnet)
        
        return self.template.format(**doc_data)
    
    def _generate_config_examples(self, subnet):
        first_ip = subnet.network_address + 1
        prefix = subnet.prefixlen
        netmask = subnet.netmask
        
        return """
### Cisco IOS
```
interface GigabitEthernet0/1
 ip address """ + str(first_ip) + " " + str(netmask) + """
 no shutdown
```

### Linux
```bash
ip addr add """ + str(first_ip) + "/" + str(prefix) + """ dev eth0
```

### Windows
```cmd
netsh interface ip set address "Ethernet" static """ + str(first_ip) + " " + str(netmask) + """
```
"""

# Usage
generator = SubnetDocumentationGenerator()
doc = generator.generate_subnet_doc('192.168.100.0/24', 4)
print(doc)
```

---

<Aside type="tip" title="Complete Automation">
These tools enable complete automation of the design, validation and documentation process for IPv4 subnetting schemes.
</Aside>

**Series Articles:**
- **[IPv4 Subnetting Fundamental Guide](/tcp-ip-networking/ipv4-subnetting-guide/)** - Mathematical foundations
- **[Practical Examples](/tcp-ip-networking/ipv4-subnetting-examples/)** - Enterprise cases  
- **[VLSM and Advanced Techniques](/tcp-ip-networking/ipv4-vlsm-advanced/)** - Advanced optimization